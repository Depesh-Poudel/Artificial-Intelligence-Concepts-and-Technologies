# -*- coding: utf-8 -*-
"""DipeshPoudel_Workshop-0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1N_ckmQZUrDKyBFRMKqY3Ct4KB5Il7Tbi

<p>
    Analyze temperature data from Tribhuwan International Airport, Kathmandu. The data spans one month with typical early winter temperatures.
</p>
<h2>Datasets:</h2>
<p>
    The <code>temperatures</code> list contains daily temperature readings in Celsius for one month. Each day includes three readings:
    <ul>
        <li>Night (00-08)</li>
        <li>Evening (08-16)</li>
        <li>Day (16-24)</li>
    </ul>
</p>
<pre>
temperatures = [8.2, 17.4, 14.1, 7.9, 18.0, 13.5, 9.0, 17.8, 13.0, 8.5,
16.5, 12.9, 7.7, 17.2, 13.3, 8.4, 16.7, 14.0, 9.5, 18.3, 13.4, 8.1,
17.9, 14.2, 7.6, 17.0, 12.8, 8.0, 16.8, 13.7, 7.8, 17.5, 13.6, 8.7,
17.1, 13.8, 9.2, 18.1, 13.9, 8.3, 16.4, 12.7, 8.9, 18.2, 13.1, 7.8,
16.6, 12.5]
</pre>

<h2><b>Task 1: Classify Temperatures</b></h2>
<p>Classify temperatures into categories:</p>
<ul>
    <li><b>Cold:</b> Below 10°C</li>
    <li><b>Mild:</b> 10°C to 15°C</li>
    <li><b>Comfortable:</b> 15°C to 20°C</li>
</ul>
<ol>
    <li>Create empty lists for each category.</li>
    <li>Sort the temperatures into the appropriate list.</li>
    <li>Print the lists to verify.</li>
</ol>

<h2><b>Task 2: Analyze Data</b></h2>
<ol>
    <li>How many times was it <b>mild</b>? Count and print.</li>
    <li>How many times was it <b>comfortable</b>? Count and print.</li>
    <li>How many times was it <b>cold</b>? Count and print.</li>
</ol>

<h2><b>Task 3: Convert Temperatures to Fahrenheit</b></h2>
<ol>
    <li>Convert each temperature from Celsius to Fahrenheit using the formula: <br>
        <code>Fahrenheit = (Celsius × 9/5) + 32</code>.
    </li>
    <li>Store the converted values in a new list.</li>
    <li>Print the Fahrenheit list.</li>
</ol>

<h2><b>Task 4: Analyze Temperature Patterns by Time of Day</b></h2>
<p>Group readings based on the time of day:</p>
<ul>
    <li><b>Night:</b> 00-08</li>
    <li><b>Evening:</b> 08-16</li>
    <li><b>Day:</b> 16-24</li>
</ul>
<ol>
    <li>Create separate lists for night, evening, and day temperatures.</li>
    <li>Assign values from the dataset to the respective lists.</li>
    <li>Calculate and print the average daytime temperature.</li>
    <li>(Optional) Plot "day vs. temperature" using Matplotlib.</li>
</ol>
"""

#Provided temperature data from Tribhuwan International Airport
temperatures = [
    8.2, 17.4, 14.1, 7.9, 18.0, 13.5, 9.0, 17.8, 13.0, 8.5,
    16.5, 12.9, 7.7, 17.2, 13.3, 8.4, 16.7, 14.0, 9.5, 18.3,
    13.4, 8.1, 17.9, 14.2, 7.6, 17.0, 12.8, 8.0, 16.8, 13.7,
    7.8, 17.5, 13.6, 8.7, 17.1, 13.8, 9.2, 18.1, 13.9, 8.3,
    16.4, 12.7, 8.9, 18.2, 13.1, 7.8, 16.6, 12.5
]

#Task 1 :- Temperature classifications
cold = [temp for temp in temperatures if temp < 10]
mild = [temp for temp in temperatures if 10 <= temp < 15]
com = [temp for temp in temperatures if 15 <= temp < 20]
print("Task 1 Results:\n")
print("Cold Temperatures:", cold)
print("Mild Temperatures:", mild)
print("Comfortable Temperatures:", com)
print("-------------------------------")


#Task 2 :- Count of temperature occuarance for each classifiaction
print("\n\nTask 2 Results:\n")
print("No of cold temperature occuarance: ", len(cold))
print("No of mild temperature occuarance: ", len(mild))
print("No of comfortable temperature occuarance: ", len(com))
print("-------------------------------")

#Task 3 :- Temperature conversion from Celsius to Fahrenheit
print("\n\nTask 3 Results:\n")
temperatures_fahrenheit=[]
for temp in temperatures:
    temp_fahr = round((temp * 9/5) + 32, 2)
    temperatures_fahrenheit.append(temp_fahr)
print("The temperatures in Fahrenheit:", temperatures_fahrenheit)
print("-------------------------------")

#Task 4 :- Analyzing Temperature Patterns by Time of Day
night_temps = [temperatures[i] for i in range(0, len(temperatures), 3)]
evening_temps = [temperatures[i+1] for i in range(0, len(temperatures), 3)]
day_temps = [temperatures[i+2] for i in range(0, len(temperatures), 3)]

# Calculate and print averages
average_day_temp = sum(day_temps) / len(day_temps)
print("\n\nTask 4 Results:\n")
print("Night Temperatures:", night_temps)
print("Evening Temperatures:", evening_temps)
print("Day Temperatures:", day_temps)
print(f"Average Day-Time Temperature: {average_day_temp:.2f}°C")
print("-------------------------------")


# Importing the Matplotlib library for plotting
import matplotlib.pyplot as plt
plt.figure(figsize=(12, 6)) #Gives the size of the plot, in this case 12 inch long and 6 inch wide.
plt.plot(day_temps, marker='o', linestyle='--', color='blue', label='Day Temperatures')
plt.title("Day vs Temperature") #The title of the plot
plt.xlabel("Day") #Labeling the x-axis
plt.ylabel("Temperature in °C") #Labeling the y-axis
plt.legend()
plt.grid(True)
plt.show()

"""<h1>Recursion Tasks</h1>
    
<h2>Task 1: Sum of Nested Lists</h2>
<p><strong>Scenario:</strong> You have a list that contains numbers and other lists of numbers (nested lists). The goal is to find the total sum of all the numbers in this structure.</p>
<p><strong>Instructions:</strong></p>
<ol>
        <li>Write a recursive function <code>sum_nested_list(nested_list)</code> that:
            <ul>
                <li>Takes a nested list (a list that can contain numbers or other lists of numbers) as input.</li>
                <li>

```
# This is formatted as code
```

Sums all numbers at every depth level of the list, regardless of how deeply nested they are.</li>
            </ul>
        </li>
        <li>Test the function with sample nested lists.</li>
</ol>
<p><strong>Example Input:</strong></p>
<pre>
nested_list = [1, [2, [3, 4], 5], 6, [7, 8]]
</pre>
<p><strong>Expected Output:</strong></p>
<pre>36</pre>

<hr>
"""

def sum_nested_list(nested_list):
    """
    Calculate the sum of all numbers in a nested list.

    Args:
        nested_list (list): A list that may contain integers or other lists of integers.

    Returns:
        int: The total sum of all integers in the nested list, including those in sublists.
    """

    total = 0
    for element in nested_list:
        if isinstance(element, list):  # Check if the element is a nested list
            total += sum_nested_list(element)  # Recursively sum the nested list
        else:
            total += element  # Add the number to the total
    return total

# Example test cases
print("Output: ")
nested_list = [1, [2, [3, 4], 5], 6, [7, 8]]
print("\tSum of list1: ",sum_nested_list(nested_list))  # Output: 36

nested_list2 = [1, [2, 3], [4, [5]]]
print("\tSum of list2: ",sum_nested_list(nested_list2))  # Output: 15

"""<h2>Task 2: Generate All Permutations of a String</h2>
  <p><strong>Scenario:</strong> Given a string, generate all possible permutations of its characters. This task involves recursion and backtracking.</p>
  <p><strong>Instructions:</strong></p>
   <ol>
        <li>Write a recursive function <code>generate_permutations(s)</code> that:
            <ul>
                <li>Takes a string <code>s</code> as input and returns a list of all unique permutations.</li>
            </ul>
        </li>
        <li>Test the function with sample strings.</li>
  </ol>
  <p><strong>Example Inputs:</strong></p>
  <pre>
generate_permutations("abc")
generate_permutations("aab")
  </pre>
  <p><strong>Expected Outputs:</strong></p>
  <pre>
['abc', 'acb', 'bac', 'bca', 'cab', 'cba']
['aab', 'aba', 'baa']
  </pre>
  <hr>
"""

def generate_permutations(s):
    """
    Generate all unique permutations of a string.

    Args:
        s (str): The input string to generate permutations for.

    Returns:
        list: A list of all unique permutations of the input string.
    """
    if len(s) == 1:
        return [s]  # Base case: single-character string has one permutation

    permutations = []
    for i, char in enumerate(s):
        # Exclude the current character and find permutations of the remaining characters
        for perm in generate_permutations(s[:i] + s[i+1:]):
            permutations.append(char + perm)
    return list(set(permutations))  # Remove duplicates if any

# Example test cases
print("Unique permutation for 'abc': ",generate_permutations("abc"))  # Output: ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']
print("Unique permutation for 'aab': ",generate_permutations("aab"))  # Output: ['aab', 'aba', 'baa']

"""<h2>Task 3: Directory Size Calculation</h2>
    <p><strong>Scenario:</strong></p>
    <p>Imagine a file system where directories can contain files (with sizes in KB) and other directories. Calculate the total size of a directory, including all nested files and subdirectories.</p>
    <p><strong>Instructions:</strong></p>
    <ol>
        <li>Write a recursive function <code>calculate_directory_size(directory)</code> that:
            <ul>
                <li>Takes a dictionary where keys represent file names (with sizes as values) or directory names (with values as nested dictionaries).</li>
                <li>Returns the total size of the directory, including all nested subdirectories.</li>
            </ul>
        </li>
        <li>Test the function with a sample directory structure.</li>
    </ol>
    <p><strong>Example Input:</strong></p>
    <pre><code>{
    "file1.txt": 200,
    "file2.txt": 300,
    "subdir1": {
        "file3.txt": 400,
        "file4.txt": 100
    },
    "subdir2": {
        "subsubdir1": {
            "file5.txt": 250
        },
        "file6.txt": 150
    }
}</code></pre>
    <p><strong>Expected Output:</strong></p>
    <pre><code>1400</code></pre>
"""

def calculate_directory_size(directory):
    """
    Calculate the total size of a directory, including all nested files and subdirectories.

    Args:
        directory (dict): A dictionary representing the directory structure.

    Returns:
        int: The total size of the directory.
    """
    total_size = 0
    for key, value in directory.items():
        if isinstance(value, dict):
            total_size += calculate_directory_size(value)  # Recursively calculate size for subdirectories
        else:
            total_size += value  # Add file size
    return total_size

# Example test case
directory_structure = {
    "file1.txt": 200,
    "file2.txt": 300,
    "subdir1": {
        "file3.txt": 400,
        "file4.txt": 100
    },
    "subdir2": {
        "subsubdir1": {
            "file5.txt": 250
        },
        "file6.txt": 150
    }
}

print("The size of the directory: ",calculate_directory_size(directory_structure))  # Output: 1400

"""<h1>Dynamic Programming: Task 1 - Coin Change Problem</h1>
    
<h2>Scenario:</h2>
<p>
        Given a set of coin denominations and a target amount, find the minimum number of coins needed to make the amount. If it’s not possible, return <code>-1</code>.
</p>
    
<h2>Task:</h2>
<p>
        Write a function <code>min_coins(coins, amount)</code> that:
</p>
<ul>
        <li>Uses Dynamic Programming (DP) to calculate the minimum number of coins needed to make up the amount.</li>
</ul>
<h3>Test with:</h3>
    <p>
        <code>coins = [1, 2, 5]</code> and <code>amount = 11</code>. The result should be <code>3</code> (using coins <code>[5, 5, 1]</code>).
    </p>
"""

def min_coins(coins, amount):
    """
    Finds the minimum number of coins needed to make a target amount using dynamic programming.
    The function calculates the fewest coins from a set of denominations that sum to the target.

    Parameters:
        coins (list of int): Available coin denominations.
        amount (int): The target amount to be formed using the coins.

    Returns:
      int: The minimum number of coins required to make the given amount.
      If it is not possible to make the amount with the given coins, returns -1.

    Example:
      >>> min_coins([1, 2, 5], 11)
      3
      >>> min_coins([2], 3)
      -1
    """
    dp = [float('inf')] * (amount + 1)  # Initialize dp array with infinity
    dp[0] = 0  # Base case: 0 coins are needed to make amount 0

    # Iterate over all coins and calculate minimum coins for each amount
    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] = min(dp[i], dp[i - coin] + 1)  # Take minimum of previous value or using this coin

    # Return the result for the given amount if it's not infinity, else return -1
    return dp[amount] if dp[amount] != float('inf') else -1

# Test Cases

#Case 1
coins = [1, 2, 5]
amount = 11
print("Minimum coins required for case 1:", min_coins(coins, amount))  # Output: 3 (using coins [5, 5, 1])

#Case 2
coins = [2]
amount = 3
print("Minimum coins required for case 2:", min_coins(coins, amount))  # Output: -1 (its impossible to make 3 with coin [2])

""" <h1>Task 2: Longest Common Subsequence (LCS)</h1>
  <p><b>Scenario:</b> Given two strings, find the length of their longest common subsequence (LCS). This is useful in text comparison.</p>
    
  <h2><b>Task:</b></h2>
  <ol>
        <li>Write a function <code>longest_common_subsequence(s1, s2)</code> that:
            <ul>
                <li>Uses Dynamic Programming (DP) to find the length of the LCS of two strings <code>s1</code> and <code>s2</code>.</li>
            </ul>
        </li>
        <li>Test with strings like <code>"abcde"</code> and <code>"ace"</code>; the LCS length should be 3 ("ace").</li>
   </ol>
"""

def longest_common_subsequence(s1, s2):
    """
    This funciton uses Dynamic Programming (DP) to find the length of the LCS of two strings s1 and s2.

    parameter:
        s1 (str): First string.
        s2 (str): Second string.

    Returns:
        int: The length of the longest common subsequence (LCS) of s1 and s2.
    """
    # Initialize a 2D DP table with dimensions (len(s1)+1) x (len(s2)+1)
    dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]

    # this fills the DP table by comparing each character in the strings
    for i in range(1, len(s1) + 1):
        for j in range(1, len(s2) + 1):
            if s1[i - 1] == s2[j - 1]:  # If characters match, extend the subsequence to get maximum subsequence length
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:  # If characters don't match, take the maximum subsequence length so far
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    # Return the length of the LCS, stored in the DP table
    return dp[len(s1)][len(s2)]

# Test the function with sample strings
s1 = "abcde"
s2 = "ace"
result = longest_common_subsequence(s1, s2)
print(f"Length of the LCS between '{s1}' and '{s2}': {result}") #

"""<h1>Task 3 - 0/1 Knapsack Problem</h1>
  <p><b>Scenario:</b> You have a list of items, each with a weight and a value. Given a weight capacity,
        maximize the total value of items you can carry without exceeding the weight capacity.</p>

  <h2><b>Task:</b></h2>
   <ol>
        <li>Write a function <code>knapsack(weights, values, capacity)</code> that:
            <ul>
                <li>Uses Dynamic Programming (DP) to determine the maximum value that can be achieved within the given weight capacity.</li>
            </ul>
        </li>
        <li>Test the function with the following input:
            <ul>
                <li><b>Weights:</b> [1, 3, 4, 5]</li>
                <li><b>Values:</b> [1, 4, 5, 7]</li>
                <li><b>Capacity:</b> 7</li>
            </ul>
            The expected result should be <b>9</b>.
        </li>
  </ol>
"""

def knapsack(weights, values, capacity):
    """
    Uses Dynamic Programming (DP) to determine the maximum value that can be achieved within the given weight capacity
    using a 0/1 Knapsack problem.
    The goal is to select items such that their total weight does not exceed the capacity
    of the knapsack, and their combined value is maximized.

    Args:
        weights (list of int): List of weights of the items.
        values (list of int): List of values of the items.
        capacity (int): Maximum weight capacity of the knapsack.

    Returns:
        int: The maximum value that can be achieved without exceeding the weight capacity.

    Example:
        >>> knapsack([1, 3, 4, 5], [1, 4, 5, 7], 7)
        9
    """
    # Number of items
    num_items = len(weights)

    # Create a DP table with dimensions (n+1) x (capacity+1)
    dp = [[0] * (capacity + 1) for _ in range(num_items + 1)]

    # Looping through all items using for loop
    for i in range(1, num_items + 1):
        for w in range(1, capacity + 1):
          # If the current item can fit into the knapsack
            if weights[i - 1] <= w:
                # Either we take the maximum value from including the item or excluding it
                dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1])
            else:  # Otherwise, don't include the item
                dp[i][w] = dp[i - 1][w]

    # The value at dp[num_items][capacity] holds the maximum value we can carry
    return dp[num_items][capacity]

# Example Test Case
weights = [1, 3, 4, 5]
values = [1, 4, 5, 7]
capacity = 7
result = knapsack(weights, values, capacity)
print(f"Maximum value that can be achieved with capacity {capacity} is: {result}")